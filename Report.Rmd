---
title: "Improvements to the 'dvir' Package"
author: "Alexander van der Voorn"
site: bookdown::bookdown_site
output: 
  bookdown::pdf_document2:
    keep_tex: yes
    toc: FALSE
    dev: cairo_pdf
    extra_dependencies:
      tikz: null
header-includes:
    #- \usepackage{setspace}\doublespacing
    - \linespread{1.25}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align="center", out.width='70%', eval = FALSE)
library(dvir)
```

\newpage
\tableofcontents

<!---
Rscript -e 'bookdown::render_book("index.Rmd")'

Need to tidy this folder to be like "report" project folder, and have everything upload to GitHub. Like include profiling results in Profiling folder etc. Then this report reference everything relatively to main folder
Move linespread package up to ectra dependencies?
Need to suss name of saved PDF, and organisation of files
Need to suss bibliography:
  citation_package: biblatex | pandoc something something
  bibliography: references.bib ?
Split PDF by section (new page) - just do it manually with \newpage{} if bookdown options don't work
  
  
  Questions for Paul:
  -Do I need to add grid:: or dvir:: to the start of functions? Just the first instance? Or all of them? or none of them?
  -Should I explicitly load packages, like hexView if I use them?
  -Do I need to repeat library(dvir) before any of the examples? Have added in report in setup code chunk
  -xColor package warnings when I knit my report? Are they an issue
  -How to find out all the conventions for things like referencing? Can I reference same report multiple times?
  -Do I worry about potential profiling differences between Cairo and non-Cairo? Probably not. Even though I profiled on screen, it's still Cairo

To remember:
  -Refer to bookdown documentation for help with caption figures and referencing them and all that
  -Can use LaTeX code in report raw!
  -TeX and LateX need {} at the end
  -Check version of dvir and R when I make final report (might need dvir 0.3-2 and R 4.1.x?). if I do, install R 4.1.x in different folder (to keep R 3.4.4 as backup and to thoroughly check result)
  -For code chunk inclusion etc.:
https://bookdown.org/yihui/rmarkdown-cookbook/hide-one.html
  -Reread all the tech notes, grid graphics info etc., TikZ, Till Tantau docs, DVI specials....
  -Research TeX Macros a little more?
  -Read Kane's report
  -If unsure start with questions as "sub-headings", like:
        What is dvir?
        Why dvir?
        What is TeX and LaTeX?
        What problems are we trying to solve?
        How have we tried to solve those problems so far?
  -Keep record of any further questions I have to research ahead of my presentation!
  -Remember I still don't know a lot of how dvir works. Like all the font shit? Read documents Paul sent for the algorithms
  -Find out how font def number works in DVI, how does it stay the same across multiple DVI files?
  -For honours talk, plan questions I could be asked, like "why not Windows?"

To do:
  -Make language more formal
  -Change 'dvir' to macro, so I can edit easily
  -Make TikZ macro (with italic i) - google how to do it
  -Make report modular, like with separate files for each section and bibliography and stuff. Use LaTeX template though for ideas!
  -Make title page and contents etc one page each
  -Tidy up this Rmd and for my other files shared to my Github, as they will all be available on Github! (especially the comments in all of them)
  -Remember gotta finish dvir driver output (format the stops and colours!)
  -Check exercise book in draw (last couple of written pages have notes on it about honours)
  -Tidy Thomas Yee's code. If not in the report, then at least on whatever appendix thing I put up on github.
  -Probably need to decide on what will be in appendix, and label it as such on Github to make it clear what's what
  -Tidy github (remove docker files for example)
  -Go through *all* meeting notes (both mine and Paul's), including my "extra" notes
  -Go through all of my report drafts and make sure I've actioned everything that's written on them. Some of things might make good discussion points either in the report or presentation!
  -For presenation, spend time again walking through dvir package, like the functions it goes through, how it does the fonts, how it converts to grobs, (and converts rectangle as in SVG to grid), anything special for TikZ...
  -Does kpsewhich run first and it finds font file locations, then adds them somewhere? Paul's flow suggests it finds fonfiles after the name - how does this work exactly?
  -Update profiling screenshots (of profvis), at least check the runtime of them and see if it's approximately 1/20th of my profiling total runtimes
  -Manually check my profiling results, to ensure that my automation of results is correct! Especially important if I need to redo profiling (so my code will still work)
  
  
  

Final formatting/proofreading things (to do on last parses through):
  -check page breaks and how figures end up (leave to very end as this depends on exactly what other text and figures are in there)
  -Ensure all writing has meaning and context (no fluffy sentences)
  -tense of writing (past tense for exisiting), be consistent with what work was done. Focus on what I want the tense to be for each section
  -we vs I (use 'we' for working through an example) - just gotta be consistent
  -Check dvir package is written same style everywhere (monospace? with quotes? ...)
  -replace `dvir` with a TeX macro
  -Check references all proper
  -Check spelling and punctuation and grammar - for this, do one section at a time to check it all!
  -Just read over it to make sure it reads well! - One section at a time
  -Fancy formatting of LaTeX and TikZ?
  -For spell check, maybe copy and paste to Word?
  -Oxford commas?
  -Figure labelling/captions/numbering (like 1.1, 1.2, 2.1....)
  -Check if `dvir` is used at start of sentence. Replace with "The dvir package"?
  -Ensure language is formal, remove any slang/casualness
  - remember alpha/infinity sign got mixed up? Check output on report....
  -Ensure writing has substance (no pointless sentences)
  -Need to research style and format for research papers and how contents page, numbering, figure, bibliography etc. work
  -Use bookdown guide for anything I ened help with in terms of formatting/layout
  -Check full stops in bullet point lists and figure captions
  -suppress any warnings in report output (console warnings are fine), but leave to end in case there are any issues
  -Capital letts in all section headings?
  -In lists, do I have commas at the end, or full stops, or nothing?
  -Check for contractions (don't use words with apostrophes (oownership okay obviously))
  -Like profiling, add information about how this report was generated (R version, dvir version etc.?). In case maybe they want to replicate generation of report?
  -Ensure I've detailed versions of `dvir` package used at each stage
  -For report output generated using dvir, fonts might not be correct! Need to embed them somehow maybe?
  -Ensure R has latest dvir version when I knit report
  -single or double quote use? And if I use them once for a term, do I need to every time?
  -Check formatting of monospace and quotes in figure captions 
  -Check sing and double quotes in general, in case I've accidentally typed a wrong one
  -Add references everywhere I can
  -Where I have quotes around for terms, like "grob", make sure throughout I use either single or double quotes and don't interchange
  -For code chunk settings, ensure they all use the same format (like single or double quotes for strings, spaces after commas, spaces either side of an '=' etc...)
--->

<!--chapter:end:index.Rmd-->

\newpage{}

# Executive summary

... goes here...

<!---
Is this the same as an abstract, or something different? Google says they are different (Executive summary = this report condensed to a paragraph, abstract = description of the things you'll find in the report, without explicitly mentioning the actual content)
--->

<!--chapter:end:01-execSummary.Rmd-->

\newpage{}

# Introduction

R has the ability to display mathematical symbols and equations in graphics using the "plotmath" feature, interpreting everything within a call to `expression()` as a mathematical equation.

<!--- Need to think of a better example than this one, ideally one that brings in our x - mu somehow --->

```{r expressionPlot, fig.cap="A plot with axis labels made using `expression()`."}
mu <- 1:5
opar <- par(mar = par()$mar + c(0, 1, 0, 0))
plot(mu, mu ^ 2 / 2, xlab = expression(mu), ylab = "", yaxt = "n")
axis(2, las = 1)
mtext(expression(frac(mu ^ 2, 2)), side = 2, line = 3, las = 1)
par(opar)
```

This provides us with most of the symbols used for equations, such as brackets and fractions, and formats them in a layout resembling \TeX{}, but it is limited in its fonts. Compare the y-axis label above with how it looks when created by \LaTeX{} in figure \@ref(fig:muOver2).

![The $y$-axis label from above, if it were created in \LaTeX](Figures/muSquaredOverTwo.PNG "muOver2"){width=5%}

<!---
Use this code for above example, just need to find a way to caption and reference it. Also delete image from figures folder when done

\begin{equation*}
\dfrac{\mu^2}{2}
\end{equation*}

could use \[\dfrac{\mu^2}{2}\] if that was easier too?
--->

The difference is stark and there are several approaches in R which can get us closer to the \LaTeX{} result (Murrell, 2018 [Revisiting Mathematical Equations in R: The 'dvir' package]).

<!--- 
for these examples following, say that Paul's report descirbes the limitations of these approaches, and replicate the examples
--->
  - [**Example:** use `extrafont` and `fontcm` packages, embed CM fonts in PDF]

  - [**Example:** use `tikzDevice` package, which creates PGF/TikZ version of plot (and as such converts all text in plot to LaTeX (including labels))]

What we want is a middle ground - being able to harness the power of \TeX{} and its typsetting capabilities on our choice of text or equation in R graphics. This is where the `dvir` package comes in - providing a simple user interface, in the style of the R `grid` graphics package [Reference R grid graphics here], by way of the `grid.latex()` function:

  - [**Example:** example of grid-based plot, changing labels and/or title with `grid.latex()`. Maybe ggplot2?]

## Where this project fits in

The `dvir` package already worked really well in a lot of cases. There were however plenty more desirable features of \TeX{} and its extensions though that had not yet been implemented by `dvir`. The power of this package is from ensuring it is comprehensive enough to meet a user's entire \TeX{} needs in R graphics without having to leave R to do annotations in \LaTeX{} itself (or Photoshop/Illustrator!). 

By keeping things "in R" users only need to learn R (and basic \TeX) code to create their graphics and their work is in one place and easily reproducible. Obviously it may not be realistic to *completely* replicate \TeX{} in R, however there were several aspects of the package identified as having a lot of potential to greatly increase its usefulness. The aspects identified were:

* the speed of the package - anecdotally it took a while to generate graphics, especially if there were many `grid.latex()` calls
* expand `dvir`'s capability of creating TikZ drawings by adding support for linear gradient fills
* adding the ability to align text from `grid.latex()` to a baseline - the natural line on which characters sit

<!--chapter:end:02-introduction.Rmd-->

\newpage{}

# Background

## TeX

\TeX{} is a program to format and typeset text, and includes some basic macros to do this. \LaTeX{} is a higher-level implementation of \TeX{}, basically consisting of a lot more macros, creating a much more user-friendly interface to \TeX{}. For example, \LaTeX{} allows one to create a document with numbered sections, title pages and bibliographies without having to write complicated \TeX{} macros themself. There are other extensions to \TeX{} that do similar things to \LaTeX{} too.

## DVI

A \TeX{} or \LaTeX{} file is just plain text, so there needs to be a step to translate this plain text to what you will see on a formatted document on a screen or page. A DVI (DeVice Independent) file is a binary file *describing* the layout of the document. For example, the height of the page, what characters to display and where, and the fonts to be used.

<!---
Explain DVI more here (and less in next section explaining dvir packages)

A DVI file describes the visual layout of the document to produce but is not specific to any type of output file (PDF, HTML, etc.)

--->

## The (pre-existing) `dvir` package {#dvirDesc}

<!---
(not sure how to make clear this is all stuff that was in 'dvir' before any of my work (and the fact I didn't change any of this high level stuff))  

DVIR BACKGROUND INFO (CHECK IF IT IS COVERED BELOW):
  Font sweep (check if this bit is added):
    run through the DVI file, identify all the fonts used, and find and record the font file locations on the system.

  The purpose of `definePDFFont()` is to do a sweep of the DVI file from `grid.latex()` looking for all fonts required, before recording the font names in the font config file, searching the relevant directories for the font files and encoding the fonts. A variable `fonts` is saved with all this information. The further sweeps over the DVI file to determine the bounding box of each character and thus entire image, and to create grid grobs and viewports each redundantly called `definePDFFont()` rather than referring to the already existing variable `fonts` from the first sweep.
--->

In a simplified form, `dvir` works by providing a high level function, `grid.latex()`, to call with the \TeX{} code of the expression or text to be displayed.

<!---
This isn't the label from earlier! Either don't relate this to the label or redo the caption or redo the text
--->
```{r fig.cap="Using `dvir` to make our caption label from earlier"}
library(dvir)
grid.latex("$x - \\mu$")
```

The following steps are taken when `grid.latex()` runs:

1. A \TeX{} document is created with the expression and a changeable default preamble and postamble.

  - [**Example:** TeX document with pre- and post-amble]
  
2. This TeX document is then processed using the local \TeX{} installation to create a DVI (DeVice Independent) file.
  
3. The DVI file is read into R. As DVI files are binary they are not easily readable by humans but the `dvir` function `readDVI()` translates the DVI file into readable text.

  - [**Example:** Extract of DVI file using `readDVI()` (not the whole thing, just the bit relevant to our example ($x - \mu$))]
  
4. Three "sweeps" of the DVI file are completed to extract necessary information about what to display in R (and where and how to display it):
  
  + Font sweep: Gather the names of all fonts used in the DVI file and locate the relevant font files on the local machine. The font information is stored in a R list as well as a `fontconfig` file.
  
  + Metric sweep: To determine the overall bounding box (size) of the expression to display. This bounding box is used to create a `grid` viewport which can encompass the entire \TeX{} passed to `grid.latex()` expression using the native DVI coordinates.
  
  + Grid sweep: Convert all text and symbols into *grobs* (grid graphical objects) 

5. These grobs are then displayed in the R graphics device as per the `grid` package.

<!--chapter:end:03-background.Rmd-->

\newpage{}

# Code speed (part 1) - removing redundant font sweeps

<!---    
Profiling:
      Use initFOnts = TRUE
      Use prof mem or similar (see 769?) for multiple runs with just data output (no fucking around with html things) - gives data and graphs
      Test for variability (this is important)
      If profiling, remove any time used for the "wrapper" stuff - ideally only focus on time spent in 'dvir' functions
      For some of the profiling, use example of text formatted in two columns (power of TeX) with equations. Maybe plot on one side and text on the other side with two grid viewports? To show it in action
      Use Cairo device specifically? Should I mention that? maybe in my code "system conditions" info, like version of ubuntu etc.....
      
      

NEED TO CHANGE EXAMPLE TO ENSURE HTML WIDGET IS CORRECT - MAYBE RERUN THEM WITH LATEST CODE FOR ALL DVIR VERSIONS?

> library(profvis)
> p <- profvis(plot(1:1000000))
> htmlwidgets::saveWidget(p, "profile.html")


First parse change:
  
  dvir/R/grid.R:grid_op_243 <- op_font_def
  dvir/R/metric.R:metric_info_243 <- op_font_def
  
    Set to op_ignore. And...
  
  [metric_info|grid_op]_247 to op_ignore (so that they do not
  RESET (or overwrite) the global fonts list (that font_info_243 set up)
  
  # Op code 247 is for preamble (so would reach ti at start of every parse through (Was it just
  # to clear anything cached?)
  # Op code 243 to 246 are all for font_def. Did we change all of them? Or just 243?
  # What happens if we find a 244?

Second parse change: (see meeting notes at start of 2021)

  + IF !initFonts THEN op_pre() should NOT reset "fonts" global
  + call it "dvir.initFonts"
  + use existing options() and getOption()
  + add new arg
    grid.latex(initFonts = getOption("dvir.initFonts"))
    change actually happens in latexGrob()
    change also happens in dviGrob()
  + dvir::set("initFonts") within dviGrob()
  + op_pre() only does set("fonts") IF get("initFonts")
  + op_font_def() needs to ...
    ALSO store font def 'op' object in fontdef
    if (is.null(get("fonts")[[fontnum]]))
       define font as normal
    else 
       if (identical(oldop, newop))
           do nothing
       else
           define font as normal
    
    Also created new identical_font() function
    Also had to change add ...
      
      if (get("initFonts") || is.null(get("fonts"))) set("fonts", vector("list", 255))
    ... in op_pre,
    
    So now if 'fonts' list in 'dvir' environment doesn't exist already, it is initialised regardless of 'initFonts'
    
    
dvir versions:
0.2-1 - Before any of my changes
0.2-2 - After first speed up 
0.3-1 - Before second speed up (had TikZ and all that, and font support changes)
0.3-2 - After second speed up



- Look back to 6th of October? 
                             That's when I think Paul did merge of first speed up
I pushed change around 09 Feb (that didn't quite work)
Second code speed ups were done in >0.3-1 (in 0.3-2 I think, unless that was already 
                                           used by Paul for another change)
Push change around 25 Feb had most of the work doen I think



To record:
      -Virtual box version
      -Ubuntu version
      -'dvir' package version
      -R version
      -That it was a Cairo device (probably use on-screen device?)
      Use 'sessionInfo()' to get some of this info?
--->
In the introduction of this report the case for the `dvir` package was motivated with a simple example of a mathematical equation. `dvir` can be used on a larger scale too.

```{r yeeExample, fig.cap="A more complicated example using `dvir`"}
xpos <- c(0, 0.25,  0.7, 1)
myplot <- function(abcd = "(a)", col = "black") {
  plot(1:9, 1:9, type = "n", xlim = c(0, 1), ylim = c(0, 1), 
       bty = "n", axes = F, xlab = "", ylab = "")
  arrows(0.5, 1, xpos, 0, length = 0.12, lwd = .7,
         col = col)  # All the arrows
  text(0.05, y = 1.1, xpd = TRUE, labels = abcd, cex = 1.0,
       font = 1, col = col)
}  # myplot
par(mfrow=c(2,2),
    mar = c(2.6, 4, 1.5, 2) + 0.1,
    font = 3,  # italic
    las = 1)
myplot()
## Convert to grid
library(gridGraphics)
grid.echo()
## Make arrows "nicer" ? 
grid.edit("arrows", grep=TRUE,
          arrow=arrow(angle=10, length=unit(.12, "in"), type="closed"),
          gp=gpar(fill="black"))
## Navigate to plot window
downViewport("graphics-window-1-1")
## Use 'dvir' to draw labels
grid.latex("\\dots", x = 0.44, y = -0.1, default.units="native")
grid.latex("$Y_* =$",
           x = 0.5, y = 1.1, default.units="native")
grid.latex("$a_1$", xpos[1], y = -0.1, default.units="native")
grid.latex("$a_2$", xpos[2], y = -0.1, default.units="native")
grid.latex("$a_{L_A}$", xpos[3], y = -0.1, default.units="native")
grid.latex("$Y_{\\pi} | Y_{\\pi} \\notin \\cal{A}$",
           x = xpos[4], y = -0.1, default.units="native")
grid.latex("$\\omega_1$",
           x = 0.18, y = 0.50, default.units="native")
grid.latex("$\\omega_2$",
           x = 0.32, y = 0.50, default.units="native")
grid.latex("$\\dots$",
           x = 0.44, y = 0.50, default.units="native")
grid.latex("$\\omega_{L_A}$",
           x = 0.54, y = 0.50, default.units="native")
grid.latex("$1 - \\sum_{s=1}^{L_A}\\omega_s$",
           x = 0.95, y = 0.50, default.units="native")
```

The example in figure \@ref{fig:yeeExample} uses nine calls to `grid.latex()` and was created by a University of Auckland lecturer using the `dvir` package to help write an assignment.

One of the first things investigated in the package was the speed of running the code. Anecdotally, generating any R graphic with non-trivial \TeX{}, like that in figure \@ref(fig:yeeExample), took a long time so it was desirable to see if we could speed it up.

To look into this the first task was to profile the existing code to let us see where in the package time was being spent. This was in `dvir` version 0.2-1. 

We visualised the profiling results using `profvis::profvis()`.

<!---
These are old examples of profvis() output. Need to refresh them!
--->

<!---
How to include and reference figures:

https://community.rstudio.com/t/cross-reference-images-in-rmarkdown/83402/2
--->
![Screenshot of `profvis::profvis()` output for the code `grid.latex("$x - \\mu$")` in `dvir` version 0.2-1.](Figures/profilingSimpleProfvis_0.2-1.PNG "profilingSimpleProfvis_0.2-1"){width=100%}

We can see the function call stack in figure \@ref(fig:profilingSimpleProfvis_0.2-1). At the bottom is the call to `grid.latex()`, which immediately calls `grid.draw()` which in turn calls `latexGrob()`. This calls `readDVI()` for about the first 20ms, then `dviGrob()` for the remaining time to the end of the original `grid.latex()` function call, and so on up the function call stack.

![Screenshot of `profvis::profvis()` output for the code creating figure \@ref(fig:yeeExample) highlighting the time spent in `engine$fontDef`.](Figures/profilingYeeProfvis_0.2-1_highlight.PNG "profilingYeeProfvis_0.2-1_highlight"){width=100%}

The `profvis::profvis()` output for our more complicated example, in figure \@ref(fig:profilingYeeProfvis_0.2-1_highlight) reveals most of the time to create the figure is in `grid.latex()`. Note that the code to draw the arrows and the "(a)" in this example is so quick it occupies the very skinny call stack on the far left of the graph. `grid.latex()` and its subsequent function calls, on the other hand, take up most of the time required to produce the example.

In figure \@ref(fig:profilingYeeProfvis_0.2-1_highlight) some blocks in the call stack have been highlighted - these are related to the `engine$fontDef` operation occuring. This is a part of the "font sweep", as was described in the introduction to `dvir` in section \@ref(dvirDesc).

In the top left corner of figure \@ref(fig:profilingYeeProfvis_0.2-1_highlight) we are told the aggregate time spent with `engine$fontDef` is 1830ms. Compared to the total time of this run (a total of about 2700ms), `dvir` is spending a *lot* of time doing these font sweeps.

What was interesting though was that after the actual font sweep the following sweeps for the metric and grid information *also* called `engine$fontDef`. As the point of the font sweep is that it finds all the font information to be used later on the following metric and grid sweeps should not need to "re-sweep" for the fonts.

![Screenshot of `profvis::profvis()` output for the code `grid.latex("$x - \\mu$")` in `dvir` version 0.2-1, highlighting `engine$fontDef`.](Figures/profilingSimpleProfvis_0.2-1_highlight.PNG "profilingSimpleProfvis_0.2-1_highlight"){width=100%}

The effect of this is very obvious in figure \@ref(fig:profilingSimpleProfvis_0.2-1_highlight) which is the same as figure \@ref(fig:profilingSimpleProfvis_0.2-1) but highlights the time spent in `engine$fontDef`. The wrappers for the font, metric and grid sweeps are `dviFonts()`, `dviMetric()` and `dvigrid()` respectively (sixth call from the bottom of the stack). Here we can see nearly all of the time spent in the metric and grid sweeps are actually redoing the font sweep!

The change to be made was simply stopping the metric and grid sweeps from doing the font sweep again.

<!--- 
Is this font sweep rewriting earlier`dvir` description? If not, should this go up there?
--->

The font sweep looks in the DVI file for op codes 243 to 246. These are the op codes for font definitions and define the name of a font and give it an identifier to reference in the DVI file when it wants to use that font to display a character. 

<!---
Need figure captions here on these code examples

I think in the package code I changed, it only refered to op code 243. Check if the other ones were also affected (244 to 246). Does font sweep do all four op codes? May need to update this bit depending on outcome

For my own learning - learn how these op codes thing work (like how the functions themselves aren't actually called) - shoul go through function process again now that Inudnerstand it more! Could be important for presentation.
--->

```{r metricFont_0.2-1, fig.cap="Metric sweep searching and recording font information in package version 0.2-1, in package file dvir/R/metric.R", eval=FALSE}
metric_info_243 <- op_font_def
```

```{r gridFont_0.2-1, fig.cap="Grid sweep searching and recording font information in package version 0.2-1, in package file dvir/R/grid.R", eval=FALSE}
grid_op_243 <- op_font_def
```

Figures \@ref{fig:metricFont_0.2-1} and \@ref{fig:gridFont_0.2-1} show the code in the `dvir` package itself where the metric and grid sweeps also redid the font sweep. `op_font_def` is a function which takes the font definition in the DVI file related to that instance of the op code and searches for and records the font information. 

```{r metricFont_0.2-2, fig.cap="Metric sweep now *not* searching and recording font information in package version 0.2-2, in package file dvir/R/metric.R", eval=FALSE}
metric_info_243 <- op_ignore
```

```{r gridFont_0.2-2, fig.cap="Grid sweep now *not* searching and recording font information in package version 0.2-2, in package file dvir/R/grid.R", eval=FALSE}
grid_op_243 <- op_ignore
```

Figures \@ref{fig:metricFont_0.2-2} and \@ref{fig:gridFont_0.2-2} show the what the code was changed to in `dvir` version 0.2-2. `op_ignore` is an empty function, so when the metric or grid sweeps comes across that op code, they now do nothing.

Unfortunately these changes by themself caused an error when running `grid.latex()`. This is because one task undertaken before the font sweep is to reset or overwrite the global fonts list (which the font sweep then writes to). The metric and grid sweeps were also doing this even though it was only intended for it to be done by the font sweep. This meant after the font sweep was completed it was overwritten by the metric and grid sweeps and so when `dvir` tried to draw the characters there was no font information to refer to.

The resetting of the global fonts list was initiated when the sweeps passed op code 247 in the DVI file, which is the preamble at the start of every DVI file.

```{r metricGlobalFont_0.2-2, fig.cap="Metric sweep now *not* resetting the global fonts list in package version 0.2-2, in package file dvir/R/metric.R", eval=FALSE}
metric_info_247 <- op_ignore
```

```{r gridGlobalFont_0.2-2, fig.cap="Grid sweep now *not* resetting the global fonts list in package version 0.2-2, in package file dvir/R/grid.R", eval=FALSE}
grid_op_247 <- op_ignore
```

Setting the metric and grid sweeps to do nothing when they pass the preamble of the DVI file, again by way of `op_ignore`, solved this problem as the global fonts list created by the font sweep is now not overwritten.

<!---
Do we want another `profvis()` output here showing the change? Might be good for visual impact. Especially simple example.


\- [**Example:** `profvis()` screenshot of simple example, showing `definePDFFont()` (after change)]

\- [**Example:** `profvis()` screenshot of Thomas Yee's example, showing `definePDFFont()` (after change)]
--->

To quantify the impact this has on code speed we recorded the time to run our examples 20 times, after an initial run to compile the package after it was loaded. The first table details the total time spent, in seconds, in each of these functions in the 20 runs before and after these changes were made.

```{r include=FALSE}
dvirLibs <- c("/media/sf_Honours_project/VM_18.04/dvir0.2-1",
              "/media/sf_Honours_project/VM_18.04/dvir0.2-2",
              "/media/sf_Honours_project/VM_18.04/dvir0.3-1",
              "/media/sf_Honours_project/VM_18.04/dvir0.3-2")
simpleProfResults <- gsub("/.+/.+/.+/", "Profiling/simple_", dvirLibs)
yeeProfResults <- gsub("simple", "yee", simpleProfResults)

measurements <- c("Total time",
                  "Total time 'grid.latex()'",
                  "Total time 'dviMetric()'",
                  "Total time 'dvigrid()'",
                  "Total time 'op_font_def()")

results <- list()
for (k in c(simpleProfResults, yeeProfResults)) {
  x <- summaryRprof(k)
  results[[k]][[measurements[1]]] <- 
    x$sampling.time
  results[[k]][[measurements[2]]] <- 
    x$by.total['"grid.latex"',"total.time"]
  results[[k]][[measurements[3]]] <- 
    x$by.total['"dviMetric"',"total.time"]
  results[[k]][[measurements[4]]] <- 
    x$by.total['"dvigrid"',"total.time"]
  # results[[k]][[measurements[5]]] <- x$by.total['"op_font_def"',"total.time"]
}
```

The second table contains the change in time as a proportion of the "before" time.

```{r echo = FALSE}
resultTable <- data.frame(before_gridlatex = c(results[[1]][[2]],
                                                results[[5]][[2]]),
                          before_metric = c(results[[1]][[3]],
                                            results[[5]][[3]]),
                          before_grid = c(results[[1]][[4]],
                                          results[[5]][[4]]),
                          after_gridlatex = c(results[[2]][[2]],
                                                results[[6]][[2]]),
                          after_metric = c(results[[2]][[3]],
                                            results[[6]][[3]]),
                          after_grid = c(results[[2]][[4]],
                                          results[[6]][[4]]))
knitr::kable(resultTable[, 1:6])
```

```{r echo = FALSE}
resultTable$gridlatex_change <- with(resultTable, 
                                     (after_gridlatex - before_gridlatex) / before_gridlatex)
resultTable$metric_change <- with(resultTable, 
                                  (after_metric - before_metric) / before_metric)
resultTable$grid_change <- with(resultTable, 
                                (after_grid - before_grid) / before_grid)
knitr::kable(resultTable[, 7:9])
```

Section to be continued with:

- Formatting above table better (rounding, units, convert to percentages, better headings, centre align etc.)
- Text/paragraph description of these results

<!---
This section needs:
-Table above finished, with caption and nicely explaining everything, with nice formatting too (nice explanatory headers etc.)
-Make tables like figures (give caption I reckon, and numbers so I can refer to them in my summary)
-Summary of results
-Above code hidden
--->

<!---
Need to actually check these results (that I summarised the right info with my R code)
--->
<!---
Does engine$fontDef show up in Rprof results?
--->

## Profiling environment specifications

The exact results obtained are specific to the computing environment used. Specific details are provided below. The sampling nature of profiling (intermittent recording of the call stack) will give different results every time it is done.

The profiling results are very specific to the computer setup used and could change considerably depending on the exact computing environment in which the `dvir` package is used. 

The profiling results in this report, in this and the next section, were calculated with the following setup:

- A virtual machine via Oracle VM Virtualbox
- Virtual machine running Ubuntu 18.04.5 LTS
- R version 3.4.4
- `dvir` package versions as described with the profiling results

<!--chapter:end:04-codeSpeed1.Rmd-->

\newpage{}

# Code speed (part 2) - font caching

The earlier code speed up was done by stopping `dvir` doing something "silly". Our further profiling lead us to find where next our code spends its time and now it was a matter of making `dvir` "smarter".

\- [**Example:** `profvis()` result showing `fontEnc()` (I think) taking long time]

- Looks like if we could save/cache a font we could reduce the amount of time to run `grid.latex()`

- `fonts` R list is re-initialised after every call to `grid.latex()`

- Is a font definition in DVI the same over different calls to `grid.latex()`? Yes! even the font def number (a number seemingly determined by TeX)

\- [**Example:** font definitions from DVI file (over multiple `grid.latex()` calls) showing same fonts have same def]

- first of all we want the `fonts` R list to persist over multiple `grid.latex()` calls in an R session. We did this by storing fonts list in the `dvir` environment (using `dvir::set()` and `dvir::get()`)

- When come across a font definition (during a font sweep), we check if that font exists - the position in `fonts` list is determined by the font def number, and so as the same fonts (theoretically) have the same font def number, we can compare the new font we've come across with what is existing in that position in the `fonts` list. If nothing exists in that position in the list, then we save it as normal. If a font does exist, then we need to check if it's the same (just in case the font def number is not unique for different fonts across different `grid.latex()` calls)

  + To do this easiest way was to expand the stored information about fonts in `fonts` to include the hex code chunk (from DVI) of the font definition

  + Then we check if all parts of the new hex code chunk are the same as the existing
  
  + [**Example:** code for new function for checking if two font definitions are the same]
  
  + If the definitions are the same, do nothing. If they are different, overwrite the existing font info with the new font info. This actually removes any concern about using only the font def number (which we're pretty sure stays the same for the same font, but maybe it doesn't) 

  + Only requirement is that the font def number is unique within a single call to grid.latex() (or rather the resulting DVI output)

- Now only need to change the initialisation (reset) of fonts list to happen on package load, rather than during `grid.latex()` call (because doing it every `grid.latex()` call defeats the purpose of storing fonts). Occasionally one might still want to reset the font cache, so added an option `options(dvir.initFonts = FALSE)` and added `initFonts = getOption("dvir.initFonts")` to `dviGrob.character()` and `dviGrob.DVI()`

  + [**Example:** show function calls with the above, and anything else that helps explain them]

But why to each of these steps? Need to flesh out more why they achieve what we want it to achieve (and any considerations we had in our thought process)

- [**Example:** Profiling results (`profvis()` and `profmem()` showing speed improvement)]

<!--chapter:end:05-codeSpeed2.Rmd-->

\newpage{}

# Linear gradient fills

## TikZ and `dvir`

TikZ is a \TeX{} package that allows drawing of pictures and diagrams in \TeX{} documents [reference TikZ report/description]:

- [**Example:** simple TikZ drawing (circles with labels, and an arrow maybe)]

- [**Example:** more complicated TikZ drawing, maybe with colouring and stuff]

The original DVI specification only needed to account for text and typesetting (and can do the most basic of rectangles too!), and so was not designed with drawing and graphics in mind. The type of instruction in the DVI file are labelled with an "op code". Each op code described a type of instruction like defining fonts, setting characters to display and vertical and horizontal cursor movements. There were four op codes however, called *DVI specials*, that can contain almost any form of instruction or values needed, such as text colour, to create a document based on the DVI file, such as Postscript or PDF.

The TikZ package uses these DVI specials to describe shapes, drawings and colours in PGF (portable graphics format) which can be translated to instructions for other viewing formats, like Postscript, PDF or SVG. How the instructions are translated is controlled by a TikZ driver. The `dvir` package includes its own TikZ driver to translate the drawing instructions into a form useful to draw the things with R grid graphics [reference Paul dvir TikZ report].

Some TikZ features were not implemented though, notably the ability to have fill colours of shapes as linear or radial gradients or patterns. The primary reason for this is that R did not support these types of fills but the latest R release in May 2021, version 4.1.0, provides support for these fills in the `grid` package, on which `dvir` is built.

- [**Example:** replicate one of the above examples in R]

- [**Example:** TikZ radial gradient fill example]

- [**Example:** Make same TikZ example as above in R with dvir (obviously fill will be blank)]

- [**Example:** Use R 4.1.0 to make a linear gradient in a shape]

As it is, the TikZ driver simply ignores any gradient or pattern fill information when creating the DVI file for `dvir`.

- [**Example:** Use `grid.tikzpicture()` for picture with gradient fill in text, but resulting R graphic does not have fill]

## Implementing TikZ linear gradient fills in `dvir`

The following steps are required to implement these TikZ fills in `dvir`:

1. Add the fill information (like gradient start and end colours, gradient radius etc.) to the DVI file created by `dvir`

2. Store this fill information during a parse by `dvir` to read the DVI file

3. Add the fill information when drawing the shape in R

To tackle step 1, we need to update the `dvir` TikZ driver file to include information about the gradient and pattern fills. As the `dvir` TikZ driver file is based on the SVG TikZ driver file, the SVG support for TikZ fills was used as a base to edit to make it specific to `dvir`.

<!---
Assuming from here on that we only care about linear gradients

Can I just talk about linear gradient fills here? The work could easily be extended (but wasn't) to radial gradients as well
--->

The information we require for the gradient fills from TikZ via the DVI file is as per the arguments for the `grid::linearGradient(...)`, which is used as an argument to `grid::gpar(fill = linearGradient(...))`, which itself is an argument to a `grid` drawing function, for example `grid::grid.rect(..., gp = gpar(fill = linearGradient(...)))`. The most important parts of defining a linear gradient fill is the colours and stops of the gradient fill. The stops of a gradient fill are the locations along the length of a gradient fill where the specified colours are. In between the stops, the gradient between stop colours either side occurs.

The `colours` and `stops` arguments of `linearGradient()` are simply vectors of colours (a character vector of colour names of hexadecimal RGB values) and locations of those colours as a proportion of the distance between the start and end points of the gradient respectively. This obviously guides us as to what information we need to get from TikZ in the DVI file so we can pass it to `dvir`.

Let us consider a simple example, a rectangle with an orange to green linear gradient fill:

```{eval=FALSE}
# Code from TeX should we want to know how to do this in TeX itself or reduce/simplify to print above the picture below. Could edit to be programatic (hide code chunk to define tikz picture code, then add that in here with results='asis' or generation of picture below)
\documentclass{standalone}
\usepackage{tikz}
\begin{document}
\begin{tikzpicture}
\filldraw [draw=black, left color=orange, right color=green] (0,0) rectangle (4,2);
\end{tikzpicture}
\end{document}
```

```{r results='asis', echo=FALSE}
latexRect <- c("\\begin{center}",
               "\\begin{tikzpicture}",
               "\\filldraw [draw=black, left color=orange, right color=green] (0,0) rectangle (4,2);",
               "\\end{tikzpicture}",
               "\\end{center}")

# y <- paste(latexRect, collapse = "")
# cat(y)
cat(latexRect)
```

The following is an extract of the DVI file when the rectangle above is generated using the SVG DVI driver included with the common \TeX{} distributions, `pgfsys-dvisvgm.def`. It has been edited slightly for readability.
<!---
The output of the linear gradient info below was element 52 after reading in the DVI file into R using 'readDVI()', in case we want to automate this later
--->

```{r dviGradientOutput, eval=FALSE}
xxx1         k=67
             x=dvisvgm:raw <g transform="matrix(1,0,0,1,56.90549,28.45274)">{?nl} 
xxx1         k=67
             x=dvisvgm:raw <g transform="matrix(2.26802,0,0,1.134,0.0,0.0)">{?nl} 
xxx1         k=66
             x=dvisvgm:raw <g transform="matrix(0.0,1.0,-1.0,0.0,0.0,0.0)">{?nl} 
xxx4         k=425
             x=dvisvgm:raw  <linearGradient id="pgfsh2" gradientTransform="rotate(90)">{?nl} 
                            <stop offset=" 0.0" stop-color=" rgb(0.0%,100.0%,0.0%) "/>{?nl} 
                            <stop offset=" 0.25" stop-color=" rgb(0.0%,100.0%,0.0%) "/>{?nl} 
                            <stop offset=" 0.5" stop-color=" rgb(50.0%,75.0%,0.0%) "/>{?nl} 
                            <stop offset=" 0.75" stop-color=" rgb(100.0%,50.0%,0.0%) "/>{?nl} 
                            <stop offset=" 1.0" stop-color=" rgb(100.0%,50.0%,0.0%) "/>{?nl} 
                            </linearGradient>{?nl} 
xxx1         k=57
             x=dvisvgm:raw <g transform="translate(-50.1875,-50.1875)"> 
xxx1         k=97
             x=dvisvgm:raw <rect width="100.375" height="100.375" style="fill:url(#pgfsh2); 
                            stroke:none"/>{?nl} 
```

We can see from this that the linear gradient definition with stops and colours is defined within a `<linearGradient>` element and given an `id` attribute. In the `<rect>` element a CSS style definition sets the fill of the rectangle by referring to the `id` of the previously defined definition. We can see in the linear gradient definition there are colours defined as RGB values and their respective stops so now we need to get the `dvir` driver file to extract the same information in a "R-friendly" form.

Section to be continued with:
<!---
- Go to `dvir` driver file and see what I've added (and try work out what bit does what to explain it! Like it gets defined in one place, then passed to another function to do something else)
- See my meeting progress notes on the matter
--->

- What have we had to change in driver file (and why?) - like specific bits of driver file

- Before and after of DVI file (using new driver) for linear gradient fill (see new information displayed)

- Why couldn't we go further?

- Next steps (to complete steps 1, 2 and 3 as detailed earlier), including discussing how this applies to radial gradient fills and pattern fills



<!---
Remember to talk about the future steps, we need to do a parse of the gradient deifnitions and store them somewhere, then next parse for actual drawing we have to match up the id values

Does SVG do it by actually drawing two rectangles? Or what?

Do I need to explain SVG format at all?

Do we even need to save linear gradient definition? Can it be used in different places, or is it always defined again if the exact same definition is used?

Need to be careful about line length in example of DVI output

maybe end by saying 'linear gradients are just a small step. For example patterns require creating grobs of the pattern definition' etc. etc.
--->

<!--chapter:end:06-linearGradientFills.Rmd-->

\newpage{}

# Text baselines

- Do all this without examples first maybe, as that will be some fiddly work?

- Demonstrate problem (with example using grid.text), especially try multi line text maybe?

- Describe algorithms for determining baselines one by one. In dviMoves, describe then the issues with choosing which one, and the potential algorithms for that

- Describe function I made to calculate all baselines using these methods

- Show result of all this (in LaTeX)

<!---
Do I need to include my baseline algorithms function? as appendix?

Should I take out the TikZ bit of the algorithms function? As it's not needed and I don't want to have to explain it.


--->

<!--chapter:end:07-textBaselines.Rmd-->

\newpage{}

# Conclusion/summary/next steps

... goes here...

<!--chapter:end:08-summary.Rmd-->

