\newpage{}

<!---

Would it be possible to go into each character in the font and get the font metrics?

VERY IMPORTANT TO TRY OUT LATEX WITH THESE, IN CASE THEY DON'T WORK

Remember for things like multi line text, would need to add baselines of each line to the total height from the text above it (or from below)



In algorithms.R, delete "plotting" stuff (currently commented out) if we don't want that to be in final product
Maybe could move plotting stuff to "examples" script? Probably nah because of the fact they don't get the right baseline in R

Need to go through algorithms.R and tidy up, and proofread comments and all that


Explicitly mention name of algorithms.R function, and maybe the examples script too?, say they're in appendix! Make it obvious it was part of the project and is provided


SHould algorithm names be monospace, or just have quotes around them? just be consistent....
--->

# Text baselines

<!---
Section outline:

- Demonstrate problem (with example using grid.text), especially try multi line text maybe?

- Describe algorithms for determining baselines one by one. In dviMoves, describe then the issues with choosing which one, and the potential algorithms for that

- Describe function I made to calculate all baselines using these methods

- Show result of all this (in LaTeX)
--->

<!---
Superceded code:


\newsavebox{\dvibox}

\newcommand{\boxreport}[2]{%
  \sbox{\dvibox}{\parbox[b]{2in}{#1}}% Change width to be '1in' if going back to better way of doing it. Better yet, get variable that takes width of text itself (like TeX examples from Paul) 
  \settowidth {\dviwidth} {\usebox{\dvibox}}%
  \usebox{\dvibox}%
  \vspace{-#2}%
  \hrule width \dviwidth height 0.1pt \relax
  \vspace{#2}%
}

\newcommand{\boxpersist}[1]{%
  \vspace{-#1}%
  \hrule width \dviwidth height 0.1pt \relax
  \vspace{#1}%
}



baselineFunc <- function(testText, 
                         algo, 
                         caption, 
                         dviMovesMethod = "all", 
                         dviMovesSelection = 1) {
  algorithmBaselines <- list()
  for (i in seq_along(testText)) {
    algorithmBaselines[[i]] <- baselines(tex = testText[i],
                                         algorithm = algo,
                                         dviMovesMethod = dviMovesMethod,
                                         dviMovesSelection = dviMovesSelection)
  }
  
  
  latexCode <- character(0)
  baselineEnviroHead <- paste0("\\begin{adjustwidth}{0.5in}{0in}\n")
  baselineEnviroFoot <- paste0("\\end{adjustwidth}\n")
  latexCode <- baselineEnviroHead
  for (i in seq_along(algorithmBaselines)) {
    latexCode <- c(latexCode, 
                   paste("\\boxreport{", 
                         testText[i], 
                         "}{", 
                         unitConvert(algorithmBaselines[[i]][1]), 
                         "}\n", 
                         sep = ""))
    if (length(algorithmBaselines[[i]]) > 1) {
      for (j in 2:length(algorithmBaselines[[i]])) {
        latexCode <- c(latexCode, 
                       paste("\\boxpersist{", 
                             unitConvert(algorithmBaselines[[i]][j]), 
                             "}\n", 
                             sep = ""))
      }
    }
    latexCode <- c(latexCode, "\\vspace{0.3cm}\n")
  }
  latexCode <- c(latexCode, baselineEnviroFoot)
  latexCode
}




```{r baselineAlex, eval = FALSE, echo = FALSE, results = "asis"}
alexLatex <- baselineFunc(testText, "alex", "Using the \\texttt{alex} algorithm to calculate the baseline.")
cat(alexLatex)
```

\begin{spacing}{1}

```{r baselineDviMoves, eval = FALSE, echo = FALSE, results = "asis"}
dviMovesLatex <- baselineFunc(testText, "dviMoves", "Using the \\texttt{dviMoves} algorithm to calculate the baselines.")

cat(dviMovesLatex)
```

\end{spacing}

```{r, echo = FALSE, eval = FALSE, results = "asis"}
latexCode <- character(0)
baselineEnviroHead <- paste0("\\begin{adjustwidth}{0.5in}{0in}\n")
baselineEnviroFoot <- paste0("\\end{adjustwidth}")
latexCode <- baselineEnviroHead
for (i in seq_along(testText)) {
    algorithmBaselines <- unit(0, "cm")
    algorithmBaselines <- unit.c(algorithmBaselines, 
                                 baselines(tex = testText[i],
                                        algorithm = "dviMoves",
                                        dviMovesMethod = "all",
                                        dviMovesSelection = dviMovesSelection))

  
  # latexCode <- c(latexCode, baselineEnviroHead)
  for (j in seq_along(algorithmBaselines)) {
    latexCode <- c(latexCode, 
                   paste("\\boxreport{", 
                         testText[i], 
                         "}{", 
                         unitConvert(algorithmBaselines[j]), 
                         "}\n\\vspace{0.3cm}\n", 
                         sep = ""))
    
    # latexCode <- c(latexCode, "\\vspace{0.3cm}\n")
  }
}

latexCode <- c(latexCode, baselineEnviroFoot)
```

\begin{spacing}{1}

```{r results = "asis", eval = FALSE, echo = FALSE}
# cat(latexCode)
```

\end{spacing}



```{r baselinePreview, eval = FALSE, echo = FALSE, results = "asis"}
previewLatex <- baselineFunc(testText, "preview", "Using the \\texttt{preview} algorithm to calculate the baseline.")
cat(previewLatex)
```

```{r baselineDvipng, eval = FALSE, echo = FALSE, results = "asis"}
dvipngLatex <- baselineFunc(testText, "dvipng", "Using the \\texttt{dvipng} algorithm to calculate the baseline.")
cat(dvipngLatex)
```



--->

```{r, include = FALSE}
# Setup the functions etc. for this section
source("../Appendices/algorithms.R")
testText <- c("test",
              "testing",
              "var",
              "varying",
              "$\\sum_{n=1}^{\\infty} 2^{-n} = 1$",
              "$\\sum\\limits_{n=1}^{\\infty} 2^{-n} = 1$",
              "$\\sum\\limits_{n=1}^{} 2^{-n} = 1$",
              "The equation is $x + \\frac{\\mu^2}{2}$",
              "The equation is $x + \\frac{\\mu}{2}$",
              "$\\frac{\\mu^2}{2} + x$ is the equation",
              "$x + \\frac{\\mu}{2}$ is the equation",
              "\\begin{minipage}{1in}Paragraph, with some line wrapping!\\end{minipage}")

# Function to convert 'grid' units to LaTeX units (changing the characters at the end basically)
unitConvert <- function(x) {
  paste0(as.numeric(x), switch(attr(x, "unit"),
                               scaledpts = "sp",
                               inches = "in",
                               points = "pt",
                               attr(x, "unit")))
}
# Function to print text and do draw baseliens for given text and baseline(s)
raiseBox <- function(text, baselineVals) {
  latex <- paste0("\\settodepth{\\dvidepth} {", 
                  text, 
                  "}%\n\\settowidth{\\dviwidth} {",
                  text,
                  "}%\n")
  
  latex <- paste0(latex, 
                  paste0("\\raisebox{\\dimexpr -\\dvidepth+", 
                         unitConvert(baselineVals),
                         "}{\\makebox[0in][l]{\\rule{\\dviwidth}{.1pt}}}%\n", 
                         collapse = ""),
                  text,
                  "\n\n",
                  collapse = "")
  latex
}

# Wrapper to call raiseBox over multiple examples, with multiple sets of baseline(s)
makeFigure <- function(examples, allBaselineVals, caption = "") {
  baselineEnviroHead <- paste0("\\begin{figure}\n\\begin{center}\n")
  baselineEnviroFoot <- paste0("\\end{center}\n\\caption{",
                               caption,
                               "}\n\\end{figure}\n")
  code <- baselineEnviroHead
  for (s in seq_along(examples)) {
    code <- c(code, 
              raiseBox(examples[s], allBaselineVals[[s]]),
              "\\vspace{0.3cm}\n")
  }
  code <- c(code, baselineEnviroFoot)
  
  paste0(code, collapse = "")
                 
}

# Wrapper to return baseline values for multiple pieces of text using baselines() function
returnBaselines <- function(testText,
                            algo, 
                            dviMovesMethod = "all", 
                            dviMovesSelection = "1") {
  algorithmBaselines <- list()
  for (i in seq_along(testText)) {
      algorithmBaselines[[i]] <- baselines(tex = testText[i],
                                           algorithm = algo,
                                           dviMovesMethod = dviMovesMethod,
                                           dviMovesSelection = dviMovesSelection)
  }
  algorithmBaselines
}

```

\newlength{\dviwidth}
\newlength{\dvidepth}
\setlength{\fboxsep}{0in}
\setlength{\parindent}{0in}

## The problem

Text characters have a baseline, that is, a horizontal line on which the characters naturally sit so all the letters appear to be in line with each other. Some letters, like a lower case "p" or "j", have a "descender". A descender is the part of a character that sits *below* the baseline. 

- [Example - showing a letter, with the baseline marked and also showing what part is the "descender" part]

`grid.text()` accounts for this baseline so when you bottom align text at a certain y-value, the descenders will actually fall below the y-value we defined, despite the bottom justification. Unfortunately, `dvir` does not account for text baselines and will do any alignment with the bounding box of the text.

- [Example - combining `grid.text()` and `grid.latex()` on same y-value to show the difference between them]

- [Example - more complicated example, say with several pieces of multiline text (only if I can demonstrate later that my function works for aligning them!)]

To fix this, `dvir` needs to obtain or calculate a value for the baseline for any given piece of text to offset the bounding box when it is drawing text. All of `dvir`'s information comes from the DVI file we either need to extract a baseline value from the DVI file itself, or calculate it *from* information in the DVI file. Unfortunately plain DVI files do not state a baseline value, rather they only detail specific placement of each charcter, so we will explore some possible methods to obtain a baseline value. These methods are referred to as algorithms from here on due to their heuristic nature.

## Implementation

To explore the algorithms detailed below and evaluate their usefulness an R function, `baselines()` has been created. This function takes several arguments, including the baseline selection algorithm as detailed below, any additional information needed for that particular algorithm, and the \TeX{} code as you would use with `grid.latex()`. The output of this function is the distance, or in some case distances, from the bottom of the bounding box of the text to the possible baseline value. These distances are returned as `grid` units. 

Once the baselines have been calculated the bounding box of the text can be bottom aligned with the y-value specified but then moved down by the value of the baseline. This means the baseline of the text will be at the specified y-value.

This function has been written to easily allow integration of other algorithms and most of the function could be directly implemented in the `dvir` package, should this baseline algorithm feature be implemented into `dvir` formally.

## Potential solutions

Several different algorithms were explored to calculate the baseline for different types of text that could be used with `grid.latex()`. These algorithms are detailed here.

### `alex` algorithm

This is a simple algorithm which was determined after inspection of some DVI files. In every DVI file, there is a statement specifying the size of the bounding box of the text.

- [**Example** of of the HiResBoundingBox statement here]

After this statement there appears to consistently be a downward move equal to the height of the bounding box of text (from the top left of the bounding box to the bottom left), and then a move upward before the first character is drawn. This algorithms take the cursor location after that upward move to be the baseline. In instances where the entire text has no descenders (i.e. the baseline is the bottom of the bounding box) there will be no upward move before the first character and a value of 0 is returned as the baseline.

```{r baselineDemo, fig.cap = "Using the \\texttt{baselines()} function, returning the baseline of \\texttt{$x - \\mu$} with the \\texttt{alex} algorithm"}
baselineValue <- baselines(tex = "$x - \\mu$", algorithm = "alex")
baselineValue
```

For plain text this algorithm works quite well. Unfortunately for many equations, particularly ones with superscripts or subscripts, and multiline text the first upward move is *not* to where the baseline is.

<!---
Where I define testText below - should I either put it in a non-visible chunk to evaluate in abckground, or just call the examples I'm going to do for each example indicudally?
--->

<!---
Here's the LaTeX stuff I need for examples!

https://www.techwalla.com/articles/horizontal-line-options-in-latex

remove eval=TRUE from these code chunks

Try some examples with \newline command instead of mini page

In an ideal world, these examples would be centred, with either fixed width line or one relative to their size. Worry about it later...

--->

```{r results = "asis", echo = FALSE}
algo <- "alex"
cat(makeFigure(testText, 
               returnBaselines(testText, 
                               algo, 
                               dviMovesMethod = "all", 
                               dviMovesSelection = "1"), 
               "The baselines as calculated using the \\texttt{alex} algorithm"))
```


<!---
TO suss with pictures of baselines
-Which exampels to show
-Centre align?
-Make colour light red
-Change width of rule to match text width (either using vriable \dviwidth like before or just choosing arbitrary value)
--->



### `dviMoves` algorithm

This is an extension of the `alex` algorithm. Rather than only taking the location after the second 'down' move, this algorithm keeps track of *all* the up and down moves of the cursor. The motivation behind this is that the upward and downward "moves" in the DVI file reflect the cursor moving to the baseline value of the next character to be typeset. Once again we assume that the first downward move after the "HiResBoundingBox" statement id from the top to the bottom of the bounding box and so this algorithm only returns the upward and downward cursor moves from there, however as DVI files have the ability to save the current cursor location, move around a bit, then reset back to the saved location, all up and down moves are recorded from the start of the DVI file.

There are two complications with this method:

- As it returns *all* the vertical positions the cursor moves to there are many possible baseline values returned. Any more than one means we have to decide which of them to choose.

- There are often several up and downward moves in the DVI file between typeset characters so in between the "useful" baselines there can be some which are not so useful or duplicates.

To account for these considerations, along with the `dviMoves` algorithm, the function also allows a choice of method to select a *single* baseline out of the many returned by the algorithm. These methods are:

#### `dviMoves` selection method `all`

<!---
Maybe add example doing length(v), just to show how many potential baselines there are for some examples
--->

This selection method will return all the baseline values as determined by the algorithm. This is useful for drawing the text with all the baseline values calculated from this method.

#### `dviMoves` selection method `index`

When this selection method is chosen, another argument to the function, `dviMovesSelection`, is used to specify a numeric index. The baseline value corresponding to that index is returned.

#### `dviMoves` selection method `bottomUp`

This is similar to the `index` method but the baseline values are first ordered from smallest to largest, before using the `dviMovesSelection` argument to select the index of the baseline value to return.

#### `dviMoves` selection method `nextChars`

This method will return the first baseline value just after a specified character in the argument `dviMovesSelection`. Characters are specified by a number, entered as a character string. This method is limited for several reasons:

* It cannot return a baseline value for any instance of a character after the first instance
* If multiple cursor moves are made before a character is drawn, the earlier moves are still recorded but with a empty character label
* Some characters are hard to type on a "normal" keyboard, for example $\mu$
* The DVI file does not actually contain the character, but rather the numeric index of it in the particular font. This is why a number has to be used to select which character it is.

<!---
Somehow get unique values of baselines here? - Nah no point, drawings look pretty good!

Could maybe try removin the top baseline value though (top of bounding box...)
--->

```{r results = "asis", echo = FALSE}
algo <- "dviMoves"
cat(makeFigure(testText, 
               returnBaselines(testText, 
                               algo, 
                               dviMovesMethod = "all", 
                               dviMovesSelection = "1"), 
               "Baselines as calculated using the \\texttt{dviMoves} algorithm"))
```


<!---
#### Future options

Some other selection methods could be:

* Taking the baseline value closest to the baseline value determined by one of these other algorithms

* prevChar

* extend dviMoves to only record position just before a character is typeset?
--->


<!---
Discussion - what does dviMoves work well or not well for?
--->

### `preview` algorithm

This algorithm uses the `preview` package [@man-preview] in \LaTeX{}. @preview-tug describes the use of the algorithm for `dvisvgm`, and it has been implemented here as it has in `matplotlib.texmanager` [@matplotlib]. 

When this algorithm is selected, the following code is added to the header of the DVI file:

```
\usepackage[active,showbox,tightpage]{preview}
\def\\showbox#1%%
{\immediate\\write16{MatplotlibBox:(\\the\\ht#1+\\the\\dp#1)x\\the\\wd#1}}
```

This results in the following line being printed in the log file.

```
MatplotlibBox:(8.04175pt+3.00005pt)x62.81718pt
```

The baseline value in this case is the value just after the `+` and can be obtained by searching the log file for this line starting with `MatplotlibBox:` and returning the value just after the `+`.

```{r results = "asis", echo = FALSE}
algo <- "preview"
cat(makeFigure(testText, 
               returnBaselines(testText, 
                               algo, 
                               dviMovesMethod = "all", 
                               dviMovesSelection = "1"), 
               "Baselines as calculated using the \\texttt{preview} algorithm"))
```

<!---
Discussion - what does it work well or not well for?
--->

### `dvipng` algorithm

The `dvipng` program [@man-dvipng] turns DVI files into PNG images. An option of `dvipng` is `--depth` which returns the baseline value in pixels. [reference dvipng package - maybe where you egt it from linux?]

The system call `dvipng --depth test.dvi` returns `depth=4` within its output so after recording the output, a simple search for `depth=` will find the baseline value.

```{r results = "asis", echo = FALSE}
algo <- "dvipng"
cat(makeFigure(testText, 
               returnBaselines(testText, 
                               algo, 
                               dviMovesMethod = "all", 
                               dviMovesSelection = "1"), 
               "Baselines as calculated using the \\texttt{dvipng} algorithm"))
```

<!---
Discussion - what does it work well or not well for?
--->

<!---
### Other potential algorithms

Some other potential algorithms but have not yet been implemented in this function include:

* "Just ask \TeX{}"
--->

## Discussion of these algorithms

<!---
Need to plot these things with latex to see if DVI moves is actuall best? And if it works for all situations?

--->

Of the algorithms considered, the `dviMoves` algorithm performed best. While most of these algorithms perform well for some or most of the examples, the `dviMoves` algorithm performs well for *all* the examples, notably for giving the option to align the baseline of *any* line of multi-line text. Utilising how it returns all baseline values for all characters it is possible to align, for example, with any character in a mathematical equation, whether it be of a different size or a superscript or subscript.

- [Example: Show examples from start of this section with baselines being used to make them aligned!]

The `preview` algorithm also calculated a baseline well for all examples, except the multi-line text. An implementation of this in `dvir` could perhaps use both the `dviMoves` and `preview` algorithms to calculate the baselines, with the default selection method being the baseline value from `dviMoves` that is closest to the baseline value calculated by the `preview` algorithm.


<!---
- mention the "matching' algorithm of dviMoves (to compare with another algorithm)

- mention the "just ask TeX for answer" method

--->
